module Bluefin
  ( -- * In brief

    -- | Bluefin is an effect system which allows you to freely mix a
    -- variety of effects, including
    --
    --  * "Bluefin.EarlyReturn", for early return
    --  * "Bluefin.Exception", for exceptions
    --  * "Bluefin.IO", for I/O
    --  * "Bluefin.State", for mutable state
    --  * "Bluefin.Stream", for streams
    --
    -- and to create your own effects in terms of existing ones
    -- ("Bluefin.Compound").
    -- Bluefin effects are accessed explicitly through
    -- value-level handles.

    -- * Why even use an effect system?

    -- ** Referential transparency

    -- |
    --
    -- Haskell is a "referentially transparent" language. Without
    -- going deeply into technical details, one consequence of
    -- referential transparency is that one can freely inline @let@
    -- bindings. For example, if we start with the following program:
    --
    -- @
    -- let x = a + b
    -- in (x + 1, x / 2)
    -- @
    --
    -- we can "inline" @x@, that is, replace occurrences of @x@ with
    -- the right hand side of its binding, @a + b@, obtaining an
    -- equivalent program:
    --
    -- @
    -- (a + b + 1, (a + b) / 2)
    -- @
    --
    -- This is not true for most languages!  For example consider this
    -- Python code
    --
    -- @
    -- first_name = input("First name> ")
    -- second_name = input("Second name> ")
    --
    -- greeting =
    --   first_name \\
    --   + ", your full name is " \\
    --   + first_name \\
    --   + " " \\
    --   + second_name
    -- @
    --
    -- When you run it, something like this happens:
    --
    -- @
    -- First name> /Simon/
    -- Second name> /Peyton Jones/
    -- @
    --
    -- and then @greeting@ is a string equal to @"Simon, your full
    -- name is Simon Peyton Jones"@.  If we inline @first_name@ you
    -- get this program:
    --
    -- @
    -- second_name = input("Second name> ")
    --
    -- greeting =
    --   input("First name> ") \\
    --   + ", your full name is " \\
    --   + input("First name> ") \\
    --   + " " \\
    --   + second_name
    -- @
    --
    -- That won't do the same thing as the original program.  Instead,
    -- the user will be asked for their first name twice, /after/
    -- being asked for their second name, something like this:
    --
    -- @
    -- Second name> /Peyton Jones/
    -- First name> /Simon/
    -- First name> /Umm, it's still Simon/
    -- @
    --
    -- and then @greeting@ will be a string equal to @"Simon, your
    -- full name is Umm, it's still Simon Peyton Jones"@.
    --
    -- Being able to freely inline @let@ bindings allows powerful
    -- refactoring and convenient understanding of programs, a great
    -- benefit of referential transparency.  In a sense, it means that
    -- let bindings do not interact at all with effects like modifying
    -- state and throwing and catching exceptions, reading input (as
    -- in the Python example above), writing outut and generally
    -- interacting with the environment.

    -- ** Monads for effects

    -- | However, referential transparency also raises an awkward
    -- question: if @let@ bindings don't interact at all with effects,
    -- because we can inline them freely, then how /can/ we perform
    -- effects in Haskell, and maintain control over the order in
    -- which various externally-observable operations occur?  For a
    -- hour-long answer, concluding with an explanation of the
    -- development of effect systems, you can watch [A History of
    -- Effect systems](https://www.youtube.com/watch?v=RsTuy1jXQ6Y) by
    -- Tom Ellis (recorded at Zurihac 2025).
    --
    -- The short answer is: 'Control.Monad.Monad's.  Monads are a
    -- general interface that permits ordering of operations.
    -- Instances of @Monad@ from early in the developement of Haskell
    -- include 'Prelude.IO', 'Control.Monad.Trans.State.State',
    -- 'Prelude.Either' and 'Control.Monad.Trans.State.Writer', all of
    -- which are still in use today.  For example, to manipulate
    -- mutable state we can't use @let@ bindings, as in:
    --
    -- @
    -- let ref = newRef "Initial value"
    --     r = f ref args
    --     v = getRef ref
    -- in "Final value: " ++ v
    -- @
    --
    -- because referential transparency means this program would mean
    -- the same thing after inlining @ref@:
    --
    -- @
    -- let r = f (newRef "Initial value") args
    --     v = getRef (newRef "Initial value")
    -- in "Final value: " ++ v
    -- @
    --
    -- which is not what we want at all.  The final value would just
    -- be @"Initial value"@. One possibility is to simulate
    -- mutable state using a specific "state passing" pattern:
    --
    -- @
    -- let s1 = "Initial value"
    --     (r, s2) = f s1 args
    --     v = s2
    -- in "Final value: " ++ v
    -- @
    --
    -- Moreover, we can define a 'Control.Monad.Trans.State.State'
    -- monad which casts the specific state passing pattern as a
    -- general pattern known as "monad":
    --
    -- @
    -- newtype State s a = State (s -> (a, s))
    --
    -- instance Monad (State s) where ...
    -- @
    --
    -- and then use @do@ notation:
    --
    -- @
    -- do ref <- newRef "Initial value"
    --     r <- f ref args
    --     v <- getRef ref
    --     pure ("Final value: " ++ v)
    -- @

    -- ** Monad transformers for multiple effects

    -- | The @State s@ monad allows manipulation a state of type @s@
    -- and the @Either e@ monad allows throwing and catching an
    -- exception of type @e@.  This property of supporting a limited
    -- set of effects is very nice, because it allows us "fine
    -- grained" control over what a component of our program may do.
    -- Inevitably, however, one wants to write components that
    -- /combine/ effects, for example to write a function that allows
    -- manipulation of a state of type @Int@ /and/ to throw an
    -- "exception" of type @String@ /and/ to perform I/O.
    --
    -- For that purpose we have "monad transformers" and "MTL style",
    -- as provided by the
    -- [@transformers@](https://hackage.haskell.org/package/transformers)
    -- and [@mtl@](https://hackage.haskell.org/package/mtl) libraries.
    -- The transformer extensions of @State@ and @Either@ are @StateT@
    -- and @ExceptT@, and the @mtl@ extensions are @MonadState@ and
    -- @MonadError@.  This isn't a transformers or MTL tutorial, so we
    -- won't go into more detail, but here is an example of a function
    -- that uses two types of effects:
    --
    -- @
    -- exampleMTL ::
    --   (MonadState Int m, MonadError String m) =>
    --   String ->
    --   m String
    -- exampleMTL name = do
    --   -- /Get the current maximum/
    --   maximum <- get
    --   let l = length name
    --   -- /Check it's not too long/
    --   if l > maximum
    --     then
    --       throwError "Name was too long"
    --     else do
    --       -- /Put the new maximum/
    --       put l
    --       -- /Return the result/
    --       pure (putStrLn ("Your name was length " ++ show l))
    -- @

    -- ** Encapsulation

    -- | Not only does this allow us to achieve "fine grained"
    -- effects, it also allows us to achieve "encapsulation".  That
    -- is, we can handle effects and remove them from the set of
    -- possible behaviors.  For example, @exampleMTL@ above has the
    -- type:
    --
    -- @
    -- exampleMTL ::
    --   (MonadState Int m, MonadError String m) =>
    --   String ->
    --   m String
    -- @
    --
    -- We can handle the @MonadState@ effect (for example, using
    -- @evalState@) and remove it from the type signature, and thereby
    -- from the set of possible behaviors:
    --
    -- @
    -- exampleMTLStateHandled ::
    --   -- /MonadState no longer appears in the type/
    --   (MonadError String m) =>
    --   String ->
    --   m String
    -- exampleMTLStateHandled name =
    --   'Prelude.flip' 'Control.Monad.Trans.State.evalStateT' (exampleMTL name)
    -- @

    -- ** Effect systems provide fine-grained effects and encapsulation
    --
    -- |
    -- This approach of building effects up from smaller pieces and
    -- then interpreting those pieces to "handle" them is the one
    -- taken by effect systems like @fused-effects@ and @polysemy@ as
    -- well as @transformers@ and @mtl@.
    --
    -- To summarize, this approach is all very nice because it allows
    -- for "fine grained effects" and "encapsulation".  "Fine grained
    -- effects" means that we can specify in the type system what
    -- effects an operation may perform.  \"Encapsulation\" takes that
    -- a step further: we can /remove/ from the set of possible
    -- effects by handling an effect.
    --
    -- ----
    --
    -- [Effects for Less](https://www.youtube.com/watch?v=0jI-AlWEwYI)
    -- by Alexis King (to Zurihac 2020)
    --
    -- Haskell's referential transparency
    --
    --
    -- The point of using an effect system is to "make invalid
    -- behavior unrepresentable" by ensuring that effects that are
    -- externally visible in the behavior of an operation are also
    -- visible in the type of the operation.
    --
    -- Historically in Haskell there has a been a tension between
    -- achieving "fine-grained effects and encapsulation" on the one
    -- hand and achieving "resource safety and predictable
    -- performance" on the other.
    --
    -- Transformers (and effect systems built along similar principles
    -- such as MTL, @polysemy@ and @fused-effects@) achieve
    -- "encapsulation and fine-grained effects", that is, you can tell
    -- which effects ... FIXME: continue




    -- | In vanilla Haskell, there is an innate trade-off between
    -- encapsulation and fine-grained effects vs.  resource safety and
    -- predictable performance. Bluefin manages to be both the
    -- _fine-grained encapsulation of effects_ and still provides
    -- predictable performance.
    --
    -- Bluefin, similar to @effectful@, also defines its own @Eff@
    -- monad, as an opaque wrapper around the IO monad, but in
    -- contrast, effects are accessed explicitly through value-level
    -- handles which occur as arguments to effectful operations.
    -- Passing effects at the value-level comes with some benefits
    -- over other effect systems like @effectful@:
    --
    --  * Type inference is better (GHC gives good constraint and
    --    argument warnings)
    --  * Multiple effects of the same type
    --  * Creating new effects is the same as creating new data types
    --    in Haskell (see "Bluefin.Compound" for more information on
    --    creating new data types).

    -- * A Comparison of effect systems

    -- ** Fine-grained Effects

    -- |
    -- - ❌ __IO__: No distinction between different effects (state, exceptions, I/O, etc.)
    -- - ✅ __ST__: But state only
    -- - ✅ __MTL__\/__fused-effects__\/__Polysemy__: Fine-grained effect management
    -- - ✅ __Bluefin__\/__effectful__: Effects are represented at the type level

    -- ** Encapsulation

    -- |
    -- - ❌ __IO__: Can handle exceptions, but they are not reflected in the type
    -- - ✅ __ST__
    -- - ✅ __MTL__\/__fused-effects__\/__Polysemy__: Exceptions handled in the function body are not present in the function's type signature
    -- - ✅ __Bluefin__\/__effectful__: Proper encapsulation of effects in the type system

    -- ** Mixing effects

    -- |
    -- - ✅ __IO__
    -- - ❌ __ST__: State only
    -- - ✅ __MTL__\/__fused-effects__\/__Polysemy__
    -- - ✅ __Bluefin__\/__effectful__

    -- ** Resource Safety

    -- |
    -- - ✅ __IO__: Operations can be bracketed (see
    --   @Control.Exception.'Control.Exception.bracket'@)
    -- - ✅ __ST__: But only only state is possible anyway
    -- - ❌ __MTL__\/__fused-effects__\/__Polysemy__: Difficult to enforce
    -- - ✅ __Bluefin__\/__effectful__: Operations can be bracketed
    --   (see @Bluefin.Eff.'Bluefin.Eff.bracket'@)

    -- ** Predictable Performance

    -- |
    -- - ✅ __IO__: Performance is easy to predict based on code structure
    -- - ✅ __ST__: Same as IO
    -- - ❌ __MTL__\/__fused-effects__\/__Polysemy__: Good performance depends critically on GHC optimization
    -- - ✅ __Bluefin__\/__effectful__: In Bluefin, effects are given named handles or are present in the type signature of the function if left unhandled
    --   Making it easy to read and surmise the performance of the code.
    --
    -- Bluefin allows for explicit control over IO\/State\/Streams, and
    -- effective scoping the effects needed to make our code useful.

    -- * Bluefin

    -- | Bluefin is a Haskell effect system with a new style of API.
    -- It is distinct from prior effect systems because effects are
    -- accessed explicitly through value-level handles which occur as
    -- arguments to effectful operations. Handles (such as
    -- 'Bluefin.State.State' handles, which allow access to mutable
    -- state) are introduced by handlers (such as
    -- 'Bluefin.State.evalState', which sets the initial state).
    -- Here's an example where a mutable state effect handle, @sn@, is
    -- introduced by its handler, 'Bluefin.State.evalState'.
    --
    -- @
    -- -- If @n < 10@ then add 10 to it, otherwise
    -- -- return it unchanged
    -- example1 :: Int -> Int
    -- example1 n = 'Bluefin.Eff.runPureEff' $
    --   -- Create a new state handle, sn, and
    --   -- initialize the value of the state to n
    --   'Bluefin.State.evalState' n $ \\sn -> do
    --     n' <- 'Bluefin.State.get' sn
    --     when (n' < 10) $
    --       'Bluefin.State.modify' sn (+ 10)
    --     get sn
    -- @
    --
    -- @
    -- >>> example1 5
    -- 15
    -- >>> example1 12
    -- 12
    -- @
    --
    -- The handle @sn@ is used in much the same way as an
    -- 'Data.STRef.STRef' or 'Data.IORef.IORef'.

    -- ** Multiple effects of the same type

    -- | A benefit of value-level effect handles is that it's simple
    -- to have multiple effects of the same type in scope at the same
    -- time.  It is simple to disambiguate them, because they are
    -- distinct values!  By contrast, existing effect systems require
    -- the disambiguation to occur at the type level, which imposes
    -- challenges.
    --
    -- Here is a Bluefin example with two mutable @Int@ state effects
    -- in scope.
    --
    -- @
    -- -- Compare two values and add 10
    -- -- to the smaller
    -- example2 :: (Int, Int) -> (Int, Int)
    -- example2 (m, n) = 'Bluefin.Eff.runPureEff' $
    --   'Bluefin.State.evalState' m $ \\sm -> do
    --     evalState n $ \\sn -> do
    --       do
    --         n' <- 'Bluefin.State.get' sn
    --         m' <- get sm
    --
    --         if n' < m'
    --           then 'Bluefin.State.modify' sn (+ 10)
    --           else modify sm (+ 10)
    --
    --       n' <- get sn
    --       m' <- get sm
    --
    --       pure (n', m')
    -- @
    --
    -- @
    -- >>> example2 (5, 10)
    -- (15, 10)
    -- >>> example2 (30, 3)
    -- (30, 13)
    -- @

    -- ** Exception handles

    -- | Bluefin exceptions are accessed through
    -- 'Bluefin.Exception.Exception' handles.  An @Exception@ handle
    -- is introduced by a handler, such as 'Bluefin.Exception.try',
    -- and that handler is where the exception, if thrown, will be
    -- handled.  This arrangement differs from normal Haskell
    -- exceptions in two ways.  Firstly, every Bluefin exception will
    -- be handled – it is not possible to have an unhandled Bluefin
    -- exception.  Secondly, a Bluefin exception can be handled in
    -- only one place – normal Haskell exceptions can be handled in a
    -- variety of places, and the closest handler of matching type on
    -- the stack will be the one that will be chosen upon
    -- 'Control.Exception.throw'.
    --
    -- @example3@ shows how to use Bluefin to calculate the sum of
    -- numbers from 1 to @n@, but stop if the sum becomes bigger than
    -- 20.  The exception handle, @ex@, which has type @Exception
    -- String e@, cannot escape the scope of its handler, @try@.  If
    -- thrown it will be handled at that @try@, and nowhere else.
    --
    -- @
    -- example3 :: Int -> Either String Int
    -- example3 n = 'Bluefin.Eff.runPureEff' $
    --   'Bluefin.Exception.try' $ \\ex -> do
    --     'Bluefin.State.evalState' 0 $ \\total -> do
    --       for_ [1..n] $ \\i -> do
    --          soFar <- 'Bluefin.State.get' total
    --          when (soFar > 20) $ do
    --            'Bluefin.Exception.throw' ex ("Became too big: " ++ show soFar)
    --          'Bluefin.State.put' total (soFar + i)
    --
    --       'Bluefin.State.get' total
    -- @
    --
    -- @
    -- >>> example3 4
    -- Right 10
    -- >>> example3 10
    -- Left "Became too big: 21"
    -- @

    -- ** Effect scoping

    -- | Bluefin's use of the type system is very similar to
    -- "Control.Monad.ST": it ensures that a handle can never escape
    -- the scope of its handler.  That is, once the handler has
    -- finished running there is no way you can use the handle
    -- anymore.
    --
    -- Here in this safe lookup function we are scooping the
    -- underlying effect @Exception (Maybe a) e@, which we have passed
    -- with the handle @ret@, @ret@ is used to return early when we’ve
    -- reached the nth element in the list we want to return.  The
    -- Exception is scoped as it handled in the function body by the
    -- effect handler @withEarlyReturn@ and thus not present in the
    -- type signature of our early return function: @(!?) :: [a] ->
    -- Int -> Maybe a@.
    --
    -- @
    -- -- Safe lookup function using scoped exception handling
    -- (!?) :: [a] -> Int -> Maybe a
    -- xs !? n = runPureEff $
    --   withEarlyReturn $ \\ret ->
    --     evalState n $ \\countdown -> do
    --       for_ xs $ \\x -> do
    --         countdown' <- get countdown
    --         when (countdown' == 0) $ do
    --           returnEarly ret (Just x)
    --         modify countdown (subtract 1)
    --
    --       pure Nothing
    -- @
    --
    -- If we remove the top level effect handlers `withEarlyReturn`
    -- and `runPureEff` we can see the type of the underlying
    -- function:
    --
    -- @
    -- safeLookupUnhandled ::
    --   (e :> es) =>
    --   Exception (Maybe a) e ->
    --   [a] ->
    --   Int ->
    --   Eff es (Maybe a)
    -- safeLookupUnhandled ret xs n = do
    --   evalState n $ \\countdown -> do
    --     for_ xs $ \\x -> do
    --       countdown' <- get countdown
    --       when (countdown' == 0) $ do
    --         returnEarly ret (Just x)
    --       modify countdown (subtract 1)
    --
    --     pure Nothing
    -- @
    --
    -- Notice that in `safeLookupUnhandled` we are still explicitly
    -- passing in the handle for effect `Exception (Maybe a) e` as
    -- `ret`. In Bluefin it easy to define effectful functions, and
    -- handle them later.

    -- ** Type signatures

    -- | The type signatures of Bluefin functions follow a common
    -- pattern which looks like
    --
    -- @
    -- (e1 :> es, ...) -> \<Handle\> e1 -> ... -> Eff es r
    -- @
    --
    -- Here @\<Handle\>@ could be, for example, @State Int@,
    -- @Exception String@ or @IOE@.  Consider the function below,
    -- @incrementReadLine@. It reads integers from standard input,
    -- accumulates them into a state; it returns when it reads the
    -- input integer @0@ and it throws an exception if it encounters
    -- an input line it cannot parse.
    --
    -- Firstly, let's look at the arguments, which are all handles to
    -- Bluefin effects.  There is a state handle, an exception handle,
    -- and an IO handle, which allow modification of an @Int@ state,
    -- throwing a @String@ exception, and performing @IO@ operations
    -- respectively.  They are each tagged with a different effect
    -- type, @e1@, @e2@ and @e3@ respectively, which are always kept
    -- polymorphic.
    --
    -- Secondly, let's look at the return value, @Eff es ()@.  This
    -- means the computation is performed in the t'Bluefin.Eff.Eff'
    -- monad and the resulting value produced is of type @()@.  @Eff@
    -- is tagged with the effect type @es@, which is also always kept
    -- polymorphic.
    --
    -- Finally, let's look at the constraints.  They are what tie
    -- together the effect tags of the arguments to the effect tag of
    -- the result.  For every argument effect tag @en@ we have a
    -- constraint @en :> es@.  That tells us the that effect handle
    -- with tag @en@ is allowed to be used within the effectful
    -- computation.  If we didn't have the @e1 :> es@ constraint, for
    -- example, that would tell us that the @State Int e1@ isn't
    -- actually used anywhere in the computation.
    --
    -- GHC and editor tools like HLS do a good job of inferring these
    -- type signatures.
    --
    -- @
    -- incrementReadLine ::
    --   (e1 :> es, e2 :> es, e3 :> es) =>
    --   State Int e1  ->
    --   Exception String e2  ->
    --   IOE e3 ->
    --   Eff es ()
    -- incrementReadLine state exception io = do
    --   'Bluefin.Jump.withJump' $ \\break -> 'Control.Monad.forever' $ do
    --     line <- 'Bluefin.IO.effIO' io getLine
    --     i <- case 'Text.Read.readMaybe' line of
    --       Nothing ->
    --         'Bluefin.Exception.throw' exception ("Couldn't read: " ++ line)
    --       Just i ->
    --         pure i
    --
    --     when (i == 0) $
    --       'Bluefin.Jump.jumpTo' break
    --
    --     'Bluefin.State.modify' state (+ i)
    -- @
    --
    -- Now let's look at how we can run such a function.  Each effect
    -- must be handled by a corresponding handler, for example
    -- 'Bluefin.State.runState' for the state effect,
    -- 'Bluefin.Exception.try' for the exception effect and
    -- 'Bluefin.Eff.runEff_' for the @IO@ effect.  The type signatures
    -- of handlers also follow a common pattern, which looks like
    --
    -- @
    -- (forall e. \<Handle\> e -> Eff (e :& es) a) -> Eff es r
    -- @
    --
    -- This means that the effect @e@, corresponding to the handle
    -- @\<Handle\> e@, has been handled and removed from the set of
    -- remaining effects, @es@.  (The signatures for
    -- 'Bluefin.Eff.runEff_' and 'Bluefin.Eff.runPureEff' are slightly
    -- different because they remove @Eff@ itself.)  Here, then, is
    -- how we can run @incrementReadLine@:
    --
    -- @
    -- runIncrementReadLine :: IO (Either String Int)
    -- runIncrementReadLine = 'Bluefin.Eff.runEff_' $ \\io -> do
    --   'Bluefin.Exception.try' $ \\exception -> do
    --     ((), r) \<- 'Bluefin.State.runState' 0 $ \\state -> do
    --       incrementReadLine state exception io
    --     pure r
    --
    -- >>> runIncrementReadLine
    -- 1
    -- 2
    -- 3
    -- 0
    -- Right 6
    -- >>>> runIncrementReadLine
    -- 1
    -- 2
    -- 3
    -- Hello
    -- Left "Couldn't read: Hello"
    -- @

    -- * Comparison to other effect systems

    -- ** Everything except @effectful@

    -- | The design of Bluefin is strongly inspired by and based on
    -- @effectful@.  All the points in [@effectful@'s comparison of itself
    -- to other effect
    -- systems](https://github.com/haskell-effectful/effectful?tab=readme-ov-file#motivation)
    -- apply to Bluefin too.

    -- ** @effectful@

    -- | The major difference between Bluefin and @effectful@ is that in
    -- Bluefin effects are represented as value-level handles whereas
    -- in @effectful@ they are represented only at the type level.
    -- @effectful@ could be described as "a well-typed implementation of
    -- the @ReaderT@ @IO@ pattern", and Bluefin could be described as
    -- a well-typed implementation of something even simpler: the
    -- [Handle
    -- pattern](https://jaspervdj.be/posts/2018-03-08-handle-pattern.html).
    -- The aim of the Bluefin style of value-level effect tracking is
    -- to make it even easier to mix effects, especially effects of
    -- the same type. Only time will tell which approach is preferable
    -- in practice.

    -- Haddock seems to have trouble with italic sections spanning
    -- lines :(

    -- | "/Why not just implement Bluefin as an alternative API on/
    -- /top of @effectful@?/"
    --
    -- It would be great to share code between the two projects!  But
    --  I don't know to implement Bluefin's "Bluefin.Compound" effects
    --  in @effectful@.

    -- * Implementation

    -- | Bluefin has a similar implementation style to @effectful@.
    -- t'Bluefin.Eff.Eff' is an opaque wrapper around 'IO',
    -- t'Bluefin.State.State' is an opaque wrapper around
    -- 'Data.IORef.IORef', and 'Bluefin.Exception.throw' throws an
    -- actual @IO@ exception.  t'Bluefin.Coroutine.Coroutine' is
    -- implemented simply as a function.
    --
    -- @
    -- newtype t'Bluefin.Eff.Eff' (es :: 'Bluefin.Eff.Effects') a = 'Bluefin.Internal.UnsafeMkEff' (IO a)
    -- newtype t'Bluefin.State.State' s (st :: Effects) = 'Bluefin.Internal.UnsafeMkState' (IORef s)
    -- newtype t'Bluefin.Coroutine.Coroutine' a b (s :: Effects) = 'Bluefin.Internal.UnsafeMkCoroutine' (a -> IO b)
    -- @
    --
    -- The type parameters of kind t'Bluefin.Eff.Effects' are phantom
    -- type parameters which track which effects can be used in an
    -- operation. Bluefin uses them to ensure that effects cannot
    -- escape the scope of their handler, in the same way that the
    -- type parameter to the 'Control.Monad.ST.ST' monad ensures that
    -- mutable state references cannot escape
    -- 'Control.Monad.ST.runST'.  When the type system indicates that
    -- there are no unhandled effects it is safe to run the underlying
    -- @IO@ action using 'System.IO.Unsafe.unsafePerformIO', which is
    -- the approach taken to implement 'Bluefin.Eff.runPureEff'.
    -- Consequently, it is impossible for a pure value retured from
    -- `runPureEff` to access any Bluefin internal state or throw a
    -- Bluefin internal exception.

    -- * Tips

    -- | * Use @NoMonoLocalBinds@ and @NoMonomorphismRestriction@ for
    -- better type inference.  (You can always change back to the
    -- default after adding inferred type signatures.)
    --
    -- * Writing a handler often requires an explicit type signature.

    -- * Creating your own effects

    -- | See "Bluefin.Compound".

    -- * Example

    -- |
    -- @
    -- countPositivesNegatives :: [Int] -> String
    -- countPositivesNegatives is = 'Bluefin.Eff.runPureEff' $
    --   'Bluefin.State.evalState' (0 :: Int) $ \\positives -> do
    --       r \<- 'Bluefin.Exception.try' $ \\ex ->
    --           evalState (0 :: Int) $ \\negatives -> do
    --               for_ is $ \\i -> do
    --                   case compare i 0 of
    --                       GT -> 'Bluefin.State.modify' positives (+ 1)
    --                       EQ -> throw ex ()
    --                       LT -> modify negatives (+ 1)
    --
    --               p <- 'Bluefin.State.get' positives
    --               n <- get negatives
    --
    --               pure $
    --                 "Positives: "
    --                   ++ show p
    --                   ++ ", negatives "
    --                   ++ show n
    --
    --       case r of
    --           Right r' -> pure r'
    --           Left () -> do
    --               p <- get positives
    --               pure $
    --                 "We saw a zero, but before that there were "
    --                   ++ show p
    --                   ++ " positives"
    -- @
  )
where

-- old bits

    -- The natural extension of @State@, @Either@ and @Writer@ that
    -- allow this are [monad
    -- /transformers/](https://hackage.haskell.org/package/transformers),
    -- @StateT@, @ExceptT@ and @WriterT@.  An operation that allows
    -- manipulation of a state of type @Int@ and to throw an
    -- "exception" of type @String@ could have type:
    --
    -- @
    -- StateT Int (Either String) r
    -- @
    --
    -- However, it could also have type
    --
    -- @
    -- ExceptT String (State Int) r
    -- @
    --
    -- [@mtl@](https://hackage.haskell.org/package/mtl) was developed
    -- to resolve this ambiguity and avoid a fixed order of
    -- interpretation.  Under @mtl@ the same operation would have
    -- type:
    --
    -- @
    -- (MonadError e, MonadState s) => m r
    -- @
    --
    -- The `MonadError` effect and the `MonadState` effect may be
    -- handled in either order.  "Effect systems" provide very similar
    -- functionality (debatably, @mtl@ is an effect system).  Here is
    -- the equivalent under
    -- [Polysemy](https://hackage.haskell.org/package/polysemy):
    --
    -- @
    -- (Member (State Int) r, Member (Error String) r) => Sem r ()
    -- @

    --  For example, if we started with
    -- the operation above, of type:
    --
    -- @
    -- ExceptT String (State Int) r
    -- @
    --
    -- then we can handle the "exception" of type @String@ using
    -- 'Control.Monad.Trans.Except.runExceptT'.  Subsequently we would
    -- be left with an operation of type @State Int r@ which can
    -- /only/ do @State Int@ effects and cannot throw exceptions.
